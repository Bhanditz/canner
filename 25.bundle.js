(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[25],{

/***/ "./node_modules/@canner/antd-relation-single_select_tree/lib/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@canner/antd-relation-single_select_tree/lib/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n__webpack_require__(/*! antd/lib/input/style */ \"./node_modules/antd/lib/input/style/index.js\");\n\nvar _input = _interopRequireDefault(__webpack_require__(/*! antd/lib/input */ \"./node_modules/antd/lib/input/index.js\"));\n\n__webpack_require__(/*! antd/lib/tree/style */ \"./node_modules/antd/lib/tree/style/index.js\");\n\nvar _tree = _interopRequireDefault(__webpack_require__(/*! antd/lib/tree */ \"./node_modules/antd/lib/tree/index.js\"));\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _update = _interopRequireDefault(__webpack_require__(/*! lodash/update */ \"./node_modules/lodash/update.js\"));\n\nvar _get = _interopRequireDefault(__webpack_require__(/*! lodash/get */ \"./node_modules/lodash/get.js\"));\n\nvar _reactContentLoader = __webpack_require__(/*! react-content-loader */ \"./node_modules/react-content-loader/dist/react-content-loader.es.js\");\n\nvar _antdShareToolbar = _interopRequireDefault(__webpack_require__(/*! @canner/antd-share-toolbar */ \"./node_modules/@canner/antd-share-toolbar/lib/index.js\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar TreeNode = _tree.default.TreeNode;\nvar Search = _input.default.Search;\n\nvar RelationTree =\n/*#__PURE__*/\nfunction (_PureComponent) {\n  _inherits(RelationTree, _PureComponent);\n\n  function RelationTree(props) {\n    var _this;\n\n    _classCallCheck(this, RelationTree);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RelationTree).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onExpand\", function (expandedKeys) {\n      _this.setState({\n        expandedKeys: expandedKeys,\n        autoExpandParent: false\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onChange\", function (e, dataList, treeData) {\n      var value = e.target.value;\n      var expandedKeys = dataList.map(function (item) {\n        if ((item.title || '').indexOf(value) > -1) {\n          return getParentKey(item.id, treeData);\n        }\n\n        return null;\n      }).filter(function (item, i, self) {\n        return item && self.indexOf(item) === i;\n      });\n\n      _this.setState({\n        expandedKeys: expandedKeys,\n        searchValue: value,\n        autoExpandParent: true\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onCheck\", function (v, info) {\n      var checkedKeys = v.checked;\n      var nodes = info.checkedNodes;\n      var _this$props = _this.props,\n          onChange = _this$props.onChange,\n          refId = _this$props.refId,\n          value = _this$props.value,\n          relationValue = _this$props.relationValue; // $FlowFixMe\n\n      var originCheckIndex = checkedKeys.indexOf(value && value.id);\n\n      if (originCheckIndex !== -1) {\n        checkedKeys.splice(originCheckIndex, 1);\n      }\n\n      if (checkedKeys[0] && !nodes[0].props.disableCheckbox) {\n        var checked = (0, _get.default)(relationValue, ['edges']).find(function (edge) {\n          return edge.cursor === checkedKeys[0];\n        }).node;\n        onChange(refId, 'connect', checked);\n      } else {\n        onChange(refId, 'disconnect', value);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderTreeNodes\", function (data, selfId, disableCheckbox, id) {\n      var _this$props2 = _this.props,\n          disabled = _this$props2.uiParams.disabled,\n          value = _this$props2.value;\n      var searchValue = _this.state.searchValue;\n      var checkedId = value && value.id;\n      return data.map(function (item, index) {\n        var matchIndex = (item.title || '').toLowerCase().indexOf(searchValue.toLowerCase());\n        var beforeStr = (item.title || '').substr(0, matchIndex);\n        var afterStr = (item.title || '').substr(matchIndex + searchValue.length);\n        var title = matchIndex > -1 ? _react.default.createElement(\"span\", null, beforeStr, _react.default.createElement(\"span\", {\n          style: {\n            color: '#f50'\n          }\n        }, searchValue), afterStr) : _react.default.createElement(\"span\", null, item.title || '');\n        var isChecked = item.key === checkedId;\n        var isSelf = item.key === selfId;\n        var newId = id ? \"\".concat(id, \"-\").concat(index) : \"\".concat(index);\n        var isDisabledByUser = disabled ? disabled(item, newId) : false;\n\n        if (item.children) {\n          return _react.default.createElement(TreeNode, {\n            title: title,\n            key: item.key,\n            dataRef: item,\n            disableCheckbox: isSelf || disableCheckbox || isDisabledByUser\n          }, _this.renderTreeNodes(item.children, selfId, isSelf || isChecked || disableCheckbox, newId));\n        }\n\n        return _react.default.createElement(TreeNode, _extends({}, item, {\n          title: title,\n          key: item.key,\n          disableCheckbox: isSelf || disableCheckbox || isDisabledByUser\n        }));\n      });\n    });\n\n    _this.state = {\n      expandedKeys: [],\n      autoExpandParent: true,\n      checkedKeys: [],\n      fetching: false,\n      searchValue: ''\n    };\n    return _this;\n  }\n\n  _createClass(RelationTree, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$state = this.state,\n          fetching = _this$state.fetching,\n          expandedKeys = _this$state.expandedKeys,\n          autoExpandParent = _this$state.autoExpandParent;\n      var _this$props3 = this.props,\n          Toolbar = _this$props3.Toolbar,\n          value = _this$props3.value,\n          toolbar = _this$props3.toolbar,\n          refId = _this$props3.refId,\n          relation = _this$props3.relation,\n          _this$props3$uiParams = _this$props3.uiParams,\n          textCol = _this$props3$uiParams.textCol,\n          relationField = _this$props3$uiParams.relationField,\n          rootValue = _this$props3.rootValue,\n          keyName = _this$props3.keyName,\n          request = _this$props3.request,\n          deploy = _this$props3.deploy,\n          schema = _this$props3.schema;\n\n      var _refId$getPathArr = refId.getPathArr(),\n          _refId$getPathArr2 = _slicedToArray(_refId$getPathArr, 2),\n          key = _refId$getPathArr2[0],\n          index = _refId$getPathArr2[1]; // $FlowFixMe\n\n\n      var selfItem = rootValue[key][index];\n\n      if (fetching) {\n        return _react.default.createElement(_reactContentLoader.List, {\n          style: {\n            maxWidth: 400\n          }\n        });\n      }\n\n      var recordValue = (0, _get.default)(rootValue, refId.remove().getPathArr());\n\n      if (toolbar && toolbar.actions) {\n        // not support export import in relation\n        delete toolbar.actions.export;\n        delete toolbar.actions.import;\n      }\n\n      return _react.default.createElement(Toolbar, null, function (relationValue) {\n        return _react.default.createElement(_antdShareToolbar.default, {\n          dataSource: relationValue,\n          toolbar: _objectSpread({}, toolbar, {\n            pagination: false\n          }),\n          recordValue: recordValue,\n          selectedValue: [],\n          items: schema[relation.to].items,\n          keyName: keyName,\n          request: request,\n          deploy: deploy\n        }, function (props) {\n          var treeData = genRelationTree({\n            data: relation.to === key ? props.value.concat(selfItem) : props.value,\n            textCol: textCol,\n            relationField: relationField,\n            treeData: [],\n            treeMap: {}\n          });\n          return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(Search, {\n            style: {\n              marginBottom: 10,\n              marginRight: 24\n            },\n            placeholder: \"Search\",\n            onChange: function onChange(e) {\n              return _this2.onChange(e, relationValue, treeData);\n            }\n          }), _react.default.createElement(_tree.default, {\n            onExpand: _this2.onExpand,\n            expandedKeys: expandedKeys,\n            autoExpandParent: autoExpandParent,\n            checkStrictly: true,\n            checkable: true,\n            onCheck: _this2.onCheck // $FlowFixMe\n            ,\n            checkedKeys: value ? [value.id] : []\n          }, _this2.renderTreeNodes(treeData, selfItem && selfItem.id)));\n        });\n      });\n    }\n  }]);\n\n  return RelationTree;\n}(_react.PureComponent);\n\nexports.default = RelationTree;\n\nfunction genRelationTree(_ref) {\n  var data = _ref.data,\n      textCol = _ref.textCol,\n      _ref$treeData = _ref.treeData,\n      treeData = _ref$treeData === void 0 ? [] : _ref$treeData,\n      _ref$treeMap = _ref.treeMap,\n      treeMap = _ref$treeMap === void 0 ? {} : _ref$treeMap,\n      relationField = _ref.relationField;\n  var leftData = [];\n  JSON.parse(JSON.stringify(data)).forEach(function (datum) {\n    if (!datum) {\n      return;\n    }\n\n    var parent = datum[relationField];\n    var title = typeof textCol === 'function' ? textCol(datum) : datum[textCol];\n\n    if (!parent || !parent.id || datum.id === parent.id) {\n      treeMap[datum.id] = \"[\".concat(treeData.length, \"]\");\n      treeData.push({\n        title: title,\n        key: datum.id,\n        children: []\n      });\n    } else if (treeMap[parent.id]) {\n      treeData = (0, _update.default)(treeData, treeMap[parent.id], function (item) {\n        treeMap[datum.id] = \"\".concat(treeMap[parent.id], \".children[\").concat(item.children.length, \"]\");\n        item.children.push({\n          title: title,\n          key: datum.id,\n          children: []\n        });\n        return item;\n      });\n    } else {\n      leftData.push(datum);\n    }\n  });\n\n  if (leftData.length && data.length === leftData.length) {\n    leftData[0][relationField].id = null;\n  }\n\n  if (leftData.length) {\n    genRelationTree({\n      data: leftData,\n      textCol: textCol,\n      treeData: treeData,\n      treeMap: treeMap,\n      relationField: relationField\n    });\n  }\n\n  return treeData;\n}\n\nfunction getParentKey(key, tree) {\n  var parentKey;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n\n    if (node.children) {\n      if (node.children.some(function (item) {\n        return item.key === key;\n      })) {\n        parentKey = node.key;\n      } else if (getParentKey(key, node.children)) {\n        parentKey = getParentKey(key, node.children);\n      }\n    }\n  }\n\n  return parentKey;\n}\n\n;\n\n//# sourceURL=webpack:///./node_modules/@canner/antd-relation-single_select_tree/lib/index.js?");

/***/ })

}]);